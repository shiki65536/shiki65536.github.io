I"¿<table>
  <tbody>
    <tr>
      <td>Fixing query in OpenSearchâ€Šâ€”â€ŠTheÂ .keywordÂ SolutionThis week, we found our API endpoint failing when searching by Identifier with <code class="language-plaintext highlighter-rouge">0974727407</code> or <code class="language-plaintext highlighter-rouge">QB02003325</code> asÂ input.The RootÂ CauseOpenSearch/Elasticsearch stores string fields in twoÂ formats:Text field (<code class="language-plaintext highlighter-rouge">identifier</code>)â€Šâ€”â€Šanalyzed and tokenized for full-text searchKeyword field** (<code class="language-plaintext highlighter-rouge">identifier.keyword</code>)â€Šâ€”â€Šstored exactly as-is for exactÂ matchingOur query was using the analyzed text field, which probablyÂ caused:Leading zeros stripped: <code class="language-plaintext highlighter-rouge">0974727407</code> â†’ <code class="language-plaintext highlighter-rouge">974727407</code>Case normalization: <code class="language-plaintext highlighter-rouge">QB02003325</code> â†’ <code class="language-plaintext highlighter-rouge">qb02003325</code>The SolutionAdd <code class="language-plaintext highlighter-rouge">.keyword</code> suffix to the field name then we can do the exact matchÂ queries:async findByIdentifier(identifier: string[]</td>
      <td>number[], include?: string[]): Promise&lt;ServicePoints[]&gt; { return this.automap(await this.findBy('identifier.keyword', identifier, include));}Key TakeawayWhen querying OpenSearch/Elasticsearch for IDs, codes, or any field requiring exact matches, always use the <code class="language-plaintext highlighter-rouge">.keyword</code>subfield. The analyzed text field is for full-text search, not precise matching.</td>
    </tr>
  </tbody>
</table>
:ET