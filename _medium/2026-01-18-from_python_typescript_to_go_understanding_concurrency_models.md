---
layout: default
title: "From Python, TypeScript to Go _ Understanding Concurrency Models"
date: Sun, 18 Jan 2026 04:16:57 +0000
excerpt: "From Python &amp; TypeScript t"
link: "https://medium.com/@shiki65536/from-python-typescript-to-go-understanding-concurrency-models-009197885f37?source=rss-374d8f1302a3------2"
image: "https://cdn-images-1.medium.com/max/1024/1*58hIi__P5Z9b3NLEVwKX7A.png"
tags: ["goroutines", "concurrency", "golang"]
---
From Python &amp; TypeScript to Go — Understanding Concurrency ModelsRecently, I built a web scraper in Go and gained deep insights into goroutines, channels, and worker pools. As a developer primarily working with Python and TypeScript, here’s my understanding of Go’s concurrency model compares to other ecosystems.Quick Comparison Table+----------------------+----------------------+----------------------+----------------------+| Feature              | Go                   | Python               | TypeScript           |+----------------------+----------------------+----------------------+----------------------+| Worker Pool          | goroutine + channel  | asyncio + Semaphore  | p-limit / Promise.all|+----------------------+----------------------+----------------------+----------------------+| Communication        | channel (CSP)        | asyncio.Queue        | Array + Promise      |+----------------------+----------------------+----------------------+----------------------+| Cancellation/Timeout | context.Context      | asyncio.wait_for     | AbortController      |+----------------------+----------------------+----------------------+----------------------+1. Worker Pool (Bounded Concurrency)```gojobs := make(chan string, 100)results := make(chan Result, 100)for i := 0; i &lt; workerCount; i++ { go worker(jobs, results)}```### Python```pythonimport asyncioimport aiohttpasync def worker(queue, session, sem, results): while True: url = await queue.get() try: async with sem: async with session.get(url) as resp: results.append(await resp.text()) finally: queue.task_done()```### TypeScript```typescriptimport pLimit from “p-limit”;const limit = pLimit(5);await Promise.all(urls.map(url =&gt; limit(() =&gt; fetch(url))));```In Go, I barely needed to think about event loops. Channel boundaries naturally provide back-pressure. Python/TS require explicit semaphores or p-limit — flexible but easy to forget.## 2. Channels / Queue (CSP Communication)### Go```gojobs := make(chan Task, 100)jobs &lt;- task // sendtask := &lt;-jobs // receive```### Python```pythonqueue = asyncio.Queue()await queue.put(task)task = await queue.get()```### TypeScript```typescriptconst queue: Task[] = [];queue.push(task);const task = queue.shift();```Go’s `select` with channels is elegant. Python’s `asyncio.Queue` works well. TypeScript often needs custom abstractions — no language-level support.## 3. Cancellation / Timeout### Go```goctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)defer cancel()resp, err := ctxhttp.Get(ctx, client, url)```### Python```pythonresult = await asyncio.wait_for(fetch(url), timeout=3.0)```### TypeScript```typescriptconst controller = new AbortController();setTimeout(() =&gt; controller.abort(), 3000);const res = await fetch(url, { signal: controller.signal });```When a request cancels, Go’s `context.Context` allows downstream goroutines exit gracefully. Python/TS can do this but require manual propagation.## 4. DependenciesGo projects need almost no third-party packages. `go build` produces a deployable binary. Python/Node require managing dependencies and environments.## ConclusionFor simple I/O scrapers, Python/NodeJS work great. But when I needed **bounded concurrency**, **request-scoped cancellation**, and **low-dependency deployment**, Go’s language-level design significantly reduced complexity.Go’s concurrency is built-in: goroutines/channels/context are standard- Python/TS are flexible: mature ecosystems, great for rapid iteration
