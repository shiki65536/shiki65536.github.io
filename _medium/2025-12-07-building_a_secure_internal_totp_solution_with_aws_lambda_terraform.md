---
layout: default
title: "Building a Secure Internal TOTP Solution with AWS Lambda, Terraform"
date: Sun, 07 Dec 2025 08:06:40 +0000
excerpt: "This is a small internal proje"
link: "https://medium.com/@shiki65536/building-a-secure-internal-totp-solution-with-aws-lambda-terraform-09f0383e3fe0?source=rss-374d8f1302a3------2"
image: "https://cdn-images-1.medium.com/max/1024/1*PZf04VwgzCZlStNtOLq20w.png"
tags: ["otp-verification", "terraform", "aws-lambda"]
---
This is a small internal project I completed about a year ago. The goal was to solve a common internal pain point: how to allow External Contractors to securely and autonomously log into company-owned third-party tools without internal staff manually sending passwords or sharing static keys.Pain PointEvery time external collaborators needed to log in, they had to contact an internal team member to retrieve OTP (One-Time Password). This was not only inefficient but also posed a security risk.Solution: Serverless TOTP ServiceI built an AWS Lambda function as the core component, responsible for securely generating the TOTP (Time-based One-Time Password). This function stores the TOTP secret key in the AWS Parameter Store.def lambda_handler(event): ssm_client = boto3.client(&#39;ssm&#39;) try: response = ssm_client.get_parameter(Name=event.get(&#39;input&#39;, &#39;otp&#39;), WithDecryption=True) secret = response[&#39;Parameter&#39;][&#39;Value&#39;]  totp = pyotp.TOTP(secret) otp = totp.now()return { &#39;statusCode&#39;: 200, &#39;body&#39;: json.dumps({&#39;message&#39;: &#39;OTP generated successfully&#39;, &#39;otp&#39;: otp}) } except Exception as e: # Error handling for missing parameter or permission issues …Security Hardening with Infrastructure as CodeSince this OTP service must only be callable by internal applications, I had to ensure the Lambda function was inaccessible from the public internet, requiring strict network isolation. All infrastructure was codified using Terraform (IaC).To ensure security, I deployed the Lambda function within our Private Subnets:VPC and Subnet Configuration:I reference existing VPC and Private Subnet IDs, ensuring the Lambda service is strictly confined to the internal network environment.Security Group:A dedicated Security Group was created. It has no inbound ports open (Ingress), guaranteeing direct external access is blocked.Tagging:We used the tag to standardize resource tags, crucial for cost allocation and resource management.Principle of Least Privilege: The Lambda function needs to retrieve the secret from SSM Parameter Store. I used an IAM Policy to strictly limit its permissions:data &quot;aws_iam_policy_document&quot; &quot;lambda_iam_ssm_policy_document&quot; { statement { sid = &quot;SSM&quot; effect = &quot;Allow&quot; actions = [&quot;ssm:GetParameter&quot;] resources = [&quot;arn:aws:ssm:${var.region}:${data.aws_caller_identity.current.account_id}:parameter/*&quot;] }}This policy only permits the Lambda to perform the `ssm:GetParameter` action, preventing it from executing any other potentially dangerous operations.ConclusionAlthough small in scope, this project successfully integrated Serverless application development, Infrastructure as Code into a cohesive system.The result is that external contractors can now autonomously and securely obtain the necessary OTP via a controlled process, freeing up internal staff from repetitive manual tasks, while significantly enhancing the overall system’s security posture.
